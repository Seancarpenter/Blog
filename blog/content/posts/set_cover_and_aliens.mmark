+++
title = "Set Cover and Aliens"
author = "Sean Carpenter"
date = "2020-01-16"
description = "A close look at the classic set cover search problem through a post-apocalyptic lens"
featured_image = "posts/2020/set_cover_and_aliens/alien_abduction.png"
libraries = ["katex"]
+++


## The Scenario
![Warning Aliens](/images/posts/2020/set_cover_and_aliens/sign.png)

The year is 3000. Aliens have invaded and enslaved nearly the entire human race. You however have somehow managed to stay safe and out of sight from your would-be alien overlords, and are safely hidden in a small house in a rural part of the country. However, supplies are beginning to wear thin, and before long you know you're going to need to retrieve these 4 different items from the abandoned buildings around you if you want to survive.

![All Items](/images/posts/2020/set_cover_and_aliens/all_items.png)

You've been hiding out here for a long time, and as such are rather familiar with the area. You know exactly where to find these items, but traveling to the different buildings for supplies is going to be risky. While you are out in the open, you're at risk of being abducted by a roving UFO's tractor beam, vaporized, or worse! Analyzing a map of the area indicates that there are 4 buildings within equal distance of each other that combined have all of the resources you need.

![The Scenario](/images/posts/2020/set_cover_and_aliens/scenario.png)

Additionally, your current circumstances indicate that you only need one of each item. Retrieving more than one copy of each item is simply not going to increase your chances of survival. With that in mind, which of these buildings should you visit to get **ALL** the items you need in the **MINIMUM** amount of trips? At a glance, it should be easy to tell that we should visit **Location 1** and **Location 4** to get the supplies we need, and that the minimum number of trips that we'll need to make to get all of our supplies is **2**. However, what if we wanted to devise an algorithm to find 100 items from 20 different locations? Well we'd need to come up with an algorithm of course! As we'll soon find out, hidden within this relatively silly scenario is a deceptively hard problem known as the [Set Cover Search Problem](https://en.wikipedia.org/wiki/Set_cover_problem). Before we try and come up with an algorithm however, let's take a step back and see if we can turn this problem into something a bit more generic.


## Abstracting The Problem

To start off with, we can think of our items and locations as a set of subsets $$S = \{S_0, S_1, S_2\ ...\}$$, and the union of all subsets in $$S$$ as the universal set $$U$$. In mathematical notation:

$$
U = \bigcup\limits^n _{i=0} S_i
$$

<p style="text-align:center"> where $$n$$ is the number of subsets in $$S$$.

$$e.g.$$

<p style="text-align:center">The universal set $$U$$ of $$\{\{1, 2\},\ \{4, 5\},\ \{2, 3\}\} = \{1, 2, 3, 4, 5\}$$

Next, we're going to use the variable $$P$$ to denote the [power set](https://en.wikipedia.org/wiki/Power_set) of $$S$$, or $$p(S)$$. The power set is defined as the set of all subsets of a given set, including the empty set $$\emptyset$$ and $$S$$ itself.

$$e.g.$$

$$
p(\{1, 2\}) = \{\{\emptyset\},\ \{1\},\ \{2\},\ \{1, 2\}\}
$$

Lastly, let's use $$O$$ to denote the **optimal** (or minimal) set cover solution to any given set of subsets $$S$$. This in constrast to a **suboptimal** set cover solution, which is a set cover solution that is **NOT** minimal.

$$e.g.$$

<p style="text-align:center">The optimal set cover solution $$O$$ of $$S$$ where $$S = \{\{1, 2\}, \{3, 4\}, \{2, 3\}\}$$ is $$\{\{1, 2\}, \{3, 4\}\}$$

## Devising A Solution

With these tools at our disposal, lets see if we can come up with an algorithm. To start, one can readily deduce that if the power set $$p(S)$$, or $$P$$, contains all possible combinations of subsets in $$S$$, and our optimal solution $$O \subset S$$, then $$O \in P$$. Therefore, every possible set cover solution in $$S$$ (be it optimal or suboptimal) can be found within $$P$$ as well. As a result, finding $$O$$ is as simple as iterating through all of the sets in $$P$$ to find the set $$S$$ with the least amount of subsets where $$\bigcup\limits^n _i S_i = U$$

Ultimately, our solution is going to look something like:

    def optimal_set_cover(S)
        P = power_set(S)
        U = universe(S)
        O = S
        for each set PSi in P
            PSi_U = universe(PSi)
            if PSi_U == U and len(PSi) < len(O)
                O = PSi
        return O

Alright! With some psuedocode to guide our path, let's try and implement a working solution in Python.

## Implementation

For starters we're going to need to write a function to generate power sets. As generating power sets isn't the focus of this post, we're simply going to use a recipe directly from the [python itertools recipe book](https://docs.python.org/3/library/itertools.html#itertools-recipes) to do it for us.

{{< highlight python >}}
from itertools import chain, combinations

def power_set(iterable):
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))
{{< /highlight >}}

```
>>> [s for s in power_set([1, 2, 3])]
[(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]
```
Note, as you can see from the sample output, this is going to generate a list of tuples instead of sets like we might expect. We could easily modify this function to convert these tuples into sets, but doing so would significantly increase our final run time complexity. Given that our code will be able handle these tuples the same as if they were sets, this is an unnecessary step that I have intentionally left out.

We're also going to need a function to generate the universe of a set of subsets. This will work pretty much exactly as described in the previous section of this post; simply iterate through a set of subsets (or sos) and union each one together to form the universe of that set of subsets.

{{< highlight python >}}
def universe(sos):
    u = set()
    for s in sos:
        u = u.union(s)
    return u
{{< /highlight >}}
```
>>> universe([{1, 2, 3}, {4, 5}, {6}])
{1, 2, 3, 4, 5, 6}
```

With these two functions at our disposal, we now have everything we need to implement our optimal set cover solution algorithm!

{{< highlight python >}}
def optimal_set_cover(sos):
    u = universe(sos)
    power_sos = power_set(sos)
    min_sos = sos # The minimal set cover solution found so far.
    for s in power_sos:
        if universe(s) == u and len(s) < len(min_sos):
            min_sos = s
    return list(min_sos)
{{< /highlight >}}
```
>>> optimal_set_cover([{1, 2}, {2, 3}, {3, 4}])
({1, 2}, {3, 4})
```

## Suboptimal Solutions
{{< highlight python >}}
def suboptimal_set_cover(sos):
    u = universe(sos)
    min_sos = [] # The minimal set cover solution found so far.
    ku = set() # The universe of elements seen so far, the "known universe".
    while ku != u:
        sos = sorted(sos, key=lambda s: len(s.difference(ku)))
        s = sos.pop()
        min_sos.append(s)
        ku = ku.union(s)

    return min_sos
{{< /highlight >}}
